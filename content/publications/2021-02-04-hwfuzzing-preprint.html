<!--type: preprint-->
<div class="item mix {{ type }}" data-date="{{ date }}">
  <div class="pubmain">
    <div class="pubassets">
      {{ hw-fuzzing-links }}
      <a href="#" class="pubcollapse">
        <i class="fa fa-expand"></i>
      </a>
    </div>

    <h4 class="pubtitle">Fuzzing Hardware Like Software</h4>
    <div class="pubauthor">
      <strong>Timothy Trippel</strong>, Kang G. Shin, Alex Chernyakhovsky,
      Garret Kelly, Dominic Rizzo, and Matthew Hicks
    </div>
    <div class="pubcite">
      <span class="label label-warning">{{ type }}</span>
      CoRR, abs/2102.02308, February {{ date_year }}.
    </div>
  </div>
  <div class="pubdetails">
    <h4>Abstract</h4>
    <p>
      Hardware flaws are permanent and potent: hardware cannot be patched once
      fabricated, and any flaws may undermine even formally verified software
      executing on top. Consequently, verification time dominates implementation
      time. The gold standard in hardware Design Verification (DV) is
      concentrated at two extremes: random dynamic verification and formal
      verification. Both techniques struggle to root out the subtle flaws in
      complex hardware that often manifest as security vulnerabilities. The root
      problem with random verification is its undirected nature, making it
      inefficient, while formal verification is constrained by the state-space
      explosion problem, making it infeasible to apply to complex designs. What
      is needed is a solution that is directed, yet under-constrained.
      <br />
      <br />
      Instead of making incremental improvements to existing hardware
      verification approaches, we leverage the observation that existing
      software fuzzers already provide such a solution; we adapt it for hardware
      verification, thus leveraging existing---more advanced---software
      verification tools. Specifically, we translate RTL hardware to a software
      model and fuzz that model. The central challenge we address is how best to
      mitigate the differences between the hardware execution model and software
      execution model. This includes: 1) how to represent test cases, 2) what is
      the hardware equivalent of a crash, 3) what is an appropriate coverage
      metric, and 4) how to create a general-purpose fuzzing harness for
      hardware.
      <br />
      <br />
      To evaluate our approach, we design, implement, and open-source a
      <em>Hardware Fuzzing Pipeline</em> that enables fuzzing hardware at scale,
      using only open-source tools. Using our pipeline, we fuzz four IP blocks
      from Google's OpenTitan Root-of-Trust chip. Our experiments reveal a two
      orders-of-magnitude reduction in run time to achieve Finite State Machine
      (FSM) coverage over traditional dynamic verification schemes. Moreover,
      with our design-agnostic harness, we achieve over 88% HDL line coverage in
      three out of four of our designs---even without any initial seeds.
    </p>
  </div>
</div>
